/**
  ******************************************************************************
  * Copyright (c) 2019 - ~, SCUT-RobotLab Development Team
  * @file   : drv_uart.c
  * @author : charlie 602894526@qq.com
  * @brief  : Code for UART driver in STM32F4 using STM32Cube_FW_F4_V1.24.0.
  * @date   : 2019-06-12
  * @Changes：
  *  Date           Author   Version    Notes
  *  2019-06-12     charlie   1.0.0     Creator
  *  2019-10-28     LWJ       1.0.1			Optimize

  * @file    drv_uart.c
  * @author  charlie 602894526@qq.com
  * @brief   Code for CAN driver in STM32F4 using STM32Cube_FW_F4_V1.23.0.
  * @date    2019-06-12
  * @version 1.0
  * @par Change Log：
  * <table>
  * <tr><th>Date        <th>Version  <th>Author    		<th>Description
  * <tr><td>2019-06-12  <td> 1.0     <td>Mentos Seetoo  <td>Creator
  * </table>
  *
  ==============================================================================
                     ##### How to use this driver #####
  ==============================================================================
    RX:
    1.在main.c 文件夹里面包含"drv_uart.h"头文件之后调用uart_init函数，传入串口句柄地址，初始化串口。
    2.调用usart_rx_callback_register 设置串口接收处理函数的指针
    3.在stm32f4xx_it.c文件里面包含"drv_uart.h"头文件，并且在对应的串口中断里面加入
      uart_receive_handler，注意使用头文件extern的结构体
    
    TX:在需要用到发送的部分直接调用HAL_UART_Transmit_DMA()函数(有待改进)
    
    @warning:
    1.由于本模块运行基于STM32CubeMX生成的代码，所以头文件extern部分常用固定的结构体
      名称,也方便其他地方调用。
  ******************************************************************************
  * @attention
  * 
  * if you had modified this file, please make sure your code does not have many 
  * bugs, update the version NO., write dowm your name and the date, the most
  * important is make sure the users will have clear and definite understanding 
  * through your new brief.
  ******************************************************************************
  */
/* Includes ------------------------------------------------------------------*/
#include "drv_uart.h"
/* Private define ------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/

static uint8_t uart4_rx_buff[USART_RX_BUFFER_SIZE];
usart_manage_obj_t usart4_manage_obj =
	{
			.call_back_f = NULL};

static uint8_t uart5_rx_buff[USART_RX_BUFFER_SIZE];
usart_manage_obj_t usart5_manage_obj =
{
		.call_back_f = NULL};

static uint8_t usart1_rx_buff[USART_RX_BUFFER_SIZE];
usart_manage_obj_t usart1_manage_obj =
		{
			.call_back_f = NULL};

static uint8_t usart2_rx_buff[USART_RX_BUFFER_SIZE];
usart_manage_obj_t usart2_manage_obj =
		{
			.call_back_f = NULL};

static uint8_t usart3_rx_buff[USART_RX_BUFFER_SIZE];
usart_manage_obj_t usart3_manage_obj =
		{
				.call_back_f = NULL};

static uint8_t usart6_rx_buff[USART_RX_BUFFER_SIZE];
usart_manage_obj_t usart6_manage_obj =
		{
				.call_back_f = NULL};
/* Private type --------------------------------------------------------------*/

/* Private function declarations ---------------------------------------------*/
static void uart_rx_idle_callback(usart_manage_obj_t *m_obj);

/* function prototypes -------------------------------------------------------*/
/**
  * @brief    initialize uart device
  * @param    void
  * @retval   void
  */
void uart_init(UART_HandleTypeDef *huart)
{
  if(huart->Instance == UART4)
	{
		usart4_manage_obj.rx_buffer = uart4_rx_buff;
    usart4_manage_obj.rx_buffer_size = USART_RX_BUFFER_SIZE;
    usart4_manage_obj.uart_h = huart;
    __HAL_UART_CLEAR_IDLEFLAG(huart);
    __HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);
    HAL_UART_Receive_DMA(huart, uart4_rx_buff, USART_RX_BUFFER_SIZE);
	}

  if (huart->Instance == UART5)
	{
		usart5_manage_obj.rx_buffer = uart5_rx_buff;
    usart5_manage_obj.rx_buffer_size = USART_RX_BUFFER_SIZE;
    usart5_manage_obj.uart_h = huart;
    __HAL_UART_CLEAR_IDLEFLAG(huart);
    __HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);
    HAL_UART_Receive_DMA(huart, uart5_rx_buff, USART_RX_BUFFER_SIZE);
	}
    
   if (huart->Instance == USART1)
	{
		usart1_manage_obj.rx_buffer = usart1_rx_buff;
    usart1_manage_obj.rx_buffer_size = USART_RX_BUFFER_SIZE;
    usart1_manage_obj.uart_h = huart;
    __HAL_UART_ENABLE_IT(huart,UART_IT_IDLE);
		__HAL_UART_CLEAR_IDLEFLAG(huart);
    HAL_UART_Receive_DMA(huart, usart1_rx_buff, USART_RX_BUFFER_SIZE);
	}
    
	if (huart->Instance == USART2)
	{
		usart2_manage_obj.rx_buffer = usart2_rx_buff;
    usart2_manage_obj.rx_buffer_size = USART_RX_BUFFER_SIZE;
    usart2_manage_obj.uart_h = huart;
    __HAL_UART_CLEAR_IDLEFLAG(huart);
    __HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);
		HAL_UART_Receive_DMA(huart, usart2_rx_buff, USART_RX_BUFFER_SIZE);
	}
   
	if (huart->Instance == USART3)
	{
		usart3_manage_obj.rx_buffer = usart3_rx_buff;
    usart3_manage_obj.rx_buffer_size = USART_RX_BUFFER_SIZE;
    usart3_manage_obj.uart_h = huart;
    __HAL_UART_CLEAR_IDLEFLAG(huart);
    __HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);
    HAL_UART_Receive_DMA(huart, usart3_rx_buff, USART_RX_BUFFER_SIZE);
	}
   
  if (huart->Instance == USART6)
	{
		usart6_manage_obj.rx_buffer = usart6_rx_buff;
    usart6_manage_obj.rx_buffer_size = USART_RX_BUFFER_SIZE;
    usart6_manage_obj.uart_h = huart;
    __HAL_UART_CLEAR_IDLEFLAG(huart);
    __HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);
    HAL_UART_Receive_DMA(huart, usart6_rx_buff, USART_RX_BUFFER_SIZE);
	}
}

/**
  * @brief   Registered user callback function
  * @param   m_obj: serial port handle
            fun: user callback function
  * @retval  void
  */
void usart_rx_callback_register(usart_manage_obj_t *m_obj, usart_call_back fun)
{
  m_obj->call_back_f = fun;
  return;
}

/**
  * @brief   Determine if the idle interrupt is triggered
  * @param   m_obj: serial port handle
  * @retval  void
  */
void uart_receive_handler(usart_manage_obj_t *m_obj)
{
  if(__HAL_UART_GET_FLAG(m_obj->uart_h,UART_FLAG_IDLE)!=RESET)
  {
    uart_rx_idle_callback(m_obj);
  }
}

/**
  * @brief   clear idle it flag after uart receive a frame data
  * @param   uart IRQHandler id
  * @usage   call in uart_receive_handler() function
  */
static void uart_rx_idle_callback(usart_manage_obj_t *m_obj)
{
  static uint16_t usart_rx_num;

  /* clear idle it flag avoid idle interrupt all the time */
  __HAL_UART_CLEAR_IDLEFLAG(m_obj->uart_h);

  /* clear DMA transfer complete flag */
  HAL_UART_DMAStop(m_obj->uart_h);

  /* handle received data in idle interrupt */
  usart_rx_num = USART_RX_BUFFER_SIZE - m_obj->uart_h->hdmarx->Instance->NDTR;
  if(m_obj->call_back_f != NULL)
    m_obj->call_back_f(m_obj->rx_buffer, usart_rx_num);
	for(;usart_rx_num > 0; usart_rx_num--)
	m_obj->rx_buffer[usart_rx_num - 1] = 0;
  HAL_UART_Receive_DMA(m_obj->uart_h, m_obj->rx_buffer, USART_RX_BUFFER_SIZE);
  
}

/************************ COPYRIGHT(C) SCUT-ROBOTLAB **************************/
